use crate::js::LoaderTypeEnum;
use crate::js::compile::{Jsx, TypeScript, Wasm};
use anyhow::Result;
use anyhow::{Error, bail};
use lazy_static::lazy_static;
use path_absolutize::Absolutize;
use regex::Regex;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::{env, fs};
use swc_bundler::Config;
use swc_bundler::Load;
use swc_bundler::ModuleData;
use swc_bundler::ModuleRecord;
use swc_bundler::Resolve;
use swc_bundler::{Bundler, ModuleType};
use swc_common::FileName;
use swc_common::FilePathMapping;
use swc_common::Globals;
use swc_common::Span;
use swc_common::errors::ColorConfig;
use swc_common::errors::Handler;
use swc_common::source_map::SourceMap;
use swc_common::sync::Lrc;
use swc_ecma_ast::*;
use swc_ecma_codegen::Emitter;
use swc_ecma_codegen::text_writer::JsWriter;
use swc_ecma_loader::resolve::Resolution;
use swc_ecma_parser::EsSyntax;
use swc_ecma_parser::Syntax;
use swc_ecma_parser::parse_file_as_module;

#[derive(Debug, Default, Clone)]
pub struct Options {
    pub minify: bool,
    pub lt: LoaderTypeEnum,
}

pub fn run_bundle(entry: &str, options: &Options) -> Result<String> {
    // Create SWC globals and an LRC sourcemap.
    let globals = Globals::default();
    let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));
    // Create the bundler.
    let mut bundler = Bundler::new(
        &globals,
        cm.clone(),
        Loader {
            cm: cm.clone(),
            options,
        },
        Resolver { options },
        Config {
            require: false,
            module: ModuleType::Iife,
            ..Default::default()
        },
        Box::new(Hook),
    );
    // Create bundle entries.
    let mut entries = HashMap::default();
    entries.insert("main".to_string(), FileName::Real(entry.into()));

    // Bundle entries.
    let bundle = bundler
        .bundle(entries)
        .map_err(|e| Error::msg(format!("{e:?}")))?
        .pop()
        .unwrap();
    let mut buf = vec![];
    {
        let mut cfg = swc_ecma_codegen::Config::default();
        cfg.minify = options.minify;
        let mut emitter = Emitter {
            cfg,
            cm: cm.clone(),
            comments: None,
            wr: Box::new(JsWriter::new(cm, "\n", &mut buf, None)),
        };

        emitter.emit_module(&bundle.module)?;
    }
    // Build source from bytes.
    let mut source = String::from_utf8(buf)?;
    if !options.minify {
        // Decorate output with the following messages.
        let messages = [
            format!("// Dune v{}\n", env!("CARGO_PKG_VERSION")),
            "// It's not recommended to edit this code manually since it's generated by `dune bundle`\n\n".into()
        ];
        messages.iter().rev().for_each(|msg| {
            source.insert_str(0, msg);
        });
    }

    Ok(source)
}

struct Loader<'s> {
    cm: Lrc<SourceMap>,
    options: &'s Options,
}

impl Load for Loader<'_> {
    fn load(&self, file: &FileName) -> Result<ModuleData, Error> {
        // We only dealing with `Real` filenames.
        let specifier = match file {
            FileName::Real(value) => value.to_string_lossy().to_string(),
            _ => unreachable!(),
        };
        // Try load the module's source-code.
        let source = load_import(&specifier, self.options.lt.clone())?;
        let path = FileName::Real(specifier.into());
        let fm = self.cm.new_source_file(path.into(), source);
        let handler =
            Handler::with_tty_emitter(ColorConfig::Auto, true, false, Some(self.cm.clone()));

        // Parse JavaScript source into an SWC module.
        let module = match parse_file_as_module(
            &fm,
            Syntax::Es(EsSyntax::default()),
            EsVersion::latest(),
            None,
            &mut vec![],
        )
        .map_err(|e| e.into_diagnostic(&handler).emit())
        {
            Ok(module) => module,
            Err(_) => std::process::exit(1),
        };
        Ok(ModuleData {
            fm,
            module,
            helpers: Default::default(),
        })
    }
}

static EXTENSIONS: &[&str] = &["js", "jsx", "ts", "tsx", "json", "wasm"];

pub type ModulePath = String;
pub type ModuleSource = String;

pub trait ModuleLoader {
    fn load(&self, specifier: &str) -> Result<ModuleSource>;
    fn resolve(&self, base: Option<&str>, specifier: &str) -> Result<ModulePath>;
}
/// Loads an import using the appropriate loader.
pub(crate) fn load_import(specifier: &str, lt: LoaderTypeEnum) -> Result<ModuleSource> {
    // Look the params and choose a loader.
    let loader: Box<dyn ModuleLoader> = match lt {
        LoaderTypeEnum::FS => Box::new(FsModuleLoader),
        //LoaderTypeEnum::DB => Box::new(FsModuleLoader),
        _ => Box::new(FsModuleLoader),
    };
    // Load module.
    loader.load(specifier)
}

#[derive(Default)]
pub struct FsModuleLoader;

impl FsModuleLoader {
    /// Transforms PathBuf into String.
    fn transform(&self, path: PathBuf) -> String {
        path.into_os_string().into_string().unwrap()
    }

    /// Checks if path is a JSON file.
    fn is_json_import(&self, path: &Path) -> bool {
        match path.extension() {
            Some(value) => value == "json",
            None => false,
        }
    }

    /// Wraps JSON data into an ES module (using v8's built in objects).
    fn wrap_json(&self, source: &str) -> String {
        format!("export default JSON.parse(`{source}`);")
    }

    /// Loads contents from a file.
    fn load_source(&self, path: &Path) -> Result<ModuleSource> {
        let source = fs::read_to_string(path)?;
        let source = match self.is_json_import(path) {
            true => self.wrap_json(source.as_str()),
            false => source,
        };

        Ok(source)
    }

    /// Loads import as file.
    fn load_as_file(&self, path: &Path) -> Result<ModuleSource> {
        // 1. Check if path is already a valid file.
        if path.is_file() {
            return self.load_source(path);
        }

        // 2. Check if we need to add an extension.
        if path.extension().is_none() {
            for ext in EXTENSIONS {
                let path = &path.with_extension(ext);
                if path.is_file() {
                    return self.load_source(path);
                }
            }
        }
        // 3. Bail out with an error.
        bail!(format!("Module not found \"{}\"", path.display()));
    }

    /// Loads import as directory using the 'index.[ext]' convention.
    fn load_as_directory(&self, path: &Path) -> Result<ModuleSource> {
        for ext in EXTENSIONS {
            let path = &path.join(format!("index.{ext}"));
            if path.is_file() {
                return self.load_source(path);
            }
        }
        bail!(format!("Module not found \"{}\"", path.display()));
    }
}

impl ModuleLoader for FsModuleLoader {
    fn load(&self, specifier: &str) -> Result<ModuleSource> {
        // Load source.
        let path = Path::new(specifier);
        let maybe_source = self
            .load_as_file(path)
            .or_else(|_| self.load_as_directory(path));

        // Append default extension (if none specified).
        let path = match path.extension() {
            Some(_) => path.into(),
            None => path.with_extension("js"),
        };
        let source = match maybe_source {
            Ok(source) => source,
            Err(_) => bail!(format!("Module not found \"{}\"", path.display())),
        };
        let path_extension = path.extension().unwrap().to_str().unwrap();
        let name = path.to_str();
        // Use a preprocessor if necessary.
        match path_extension {
            "wasm" => Ok(Wasm::parse(&source)),
            "ts" => TypeScript::compile(name, &source),
            "jsx" => Jsx::compile(name, &source),
            "tsx" => {
                Jsx::compile(name, &source).and_then(|output| TypeScript::compile(name, &output))
            }
            _ => Ok(source),
        }
    }
    fn resolve(&self, base: Option<&str>, specifier: &str) -> Result<ModulePath> {
        // Windows platform full path regex.
        lazy_static! {
            static ref WINDOWS_REGEX: Regex = Regex::new(r"^[a-zA-Z]:\\").unwrap();
        }

        // Resolve absolute import.
        if specifier.starts_with('/') || WINDOWS_REGEX.is_match(specifier) {
            return Ok(self.transform(Path::new(specifier).absolutize()?.to_path_buf()));
        }

        // Resolve relative import.
        let cwd = &env::current_dir()?;
        let base = base.map(|v| Path::new(v).parent().unwrap()).unwrap_or(cwd);

        if specifier.starts_with("./") || specifier.starts_with("../") {
            return Ok(self.transform(base.join(specifier).absolutize()?.to_path_buf()));
        }

        bail!(format!("Module not found \"{specifier}\""));
    }
}

#[allow(unused)]
struct Resolver<'a> {
    options: &'a Options,
}

impl Resolve for Resolver<'_> {
    fn resolve(&self, base: &FileName, specifier: &str) -> Result<Resolution, Error> {
        // We only dealing with `Real` filenames.
        let base = match base {
            FileName::Real(value) => value.to_str(),
            _ => unreachable!(),
        };

        // Try resolve the specifier.
        Ok(Resolution {
            filename: FileName::Real(Path::new(&resolve_import(base, specifier)?).to_path_buf()),
            slug: None,
        })
    }
}

/// Resolves an import using the appropriate loader.
pub fn resolve_import(base: Option<&str>, specifier: &str) -> Result<ModulePath> {
    let loader: Box<dyn ModuleLoader> = {
        //let is_core_module_import = CORE_MODULES.contains_key(specifier.as_str());
        // let is_core_module_import = false;
        // let is_url_import = false;
        // match (is_core_module_import, is_url_import) {
        //     //(true, _) if !ignore_core_modules => Box::new(CoreModuleLoader),
        //     //(_, true) => Box::<UrlModuleLoader>::default(),
        //     _ => Box::new(FsModuleLoader),
        // }
        Box::new(FsModuleLoader)
    };
    // Resolve module.
    loader.resolve(base, specifier)
}

struct Hook;

impl swc_bundler::Hook for Hook {
    fn get_import_meta_props(
        &self,
        span: Span,
        module: &ModuleRecord,
    ) -> Result<Vec<KeyValueProp>, Error> {
        // 1. 取出模块的文件名
        let file_name = module.file_name.to_string();
        let file_name = resolve_import(None, &file_name)?;

        // 2. 返回 import.meta 的属性集合
        Ok(vec![
            // import.meta.url = "<模块路径>"
            KeyValueProp {
                key: PropName::Ident(IdentName::new("url".into(), span)),
                value: Box::new(Expr::Lit(Lit::Str(Str {
                    span,
                    raw: None,
                    value: file_name.into(),
                }))),
            },
            // import.meta.main = true/false
            KeyValueProp {
                key: PropName::Ident(IdentName::new("main".into(), span)),
                value: Box::new(if module.is_entry {
                    // 如果是入口模块，就生成：import.meta.main
                    Expr::Member(MemberExpr {
                        span,
                        obj: Box::new(Expr::MetaProp(MetaPropExpr {
                            span,
                            kind: MetaPropKind::ImportMeta,
                        })),
                        prop: MemberProp::Ident(IdentName::new("main".into(), span)),
                    })
                } else {
                    // 否则：false
                    Expr::Lit(Lit::Bool(Bool { span, value: false }))
                }),
            },
        ])
    }
}
