//! process

mod instruct;
mod process;

pub use instruct::*;
pub use process::*;

#[cfg(test)]
mod tests {

    use vt100::Parser;

    const TEST_DATA1: &[u8] = &[
        0x2D, 0x62, 0x61, 0x73, 0x68, 0x3A, 0x20, 0x41, 0x41, 0x41, 0x3A, 0x20, 0x72, 0x65, 0x61,
        0x64, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x0D,
        0x0A, 0x1B, 0x5D, 0x30, 0x3B, 0x72, 0x6F, 0x6F, 0x74, 0x40, 0x4B, 0x56, 0x4D, 0x5F, 0x56,
        0x4D, 0x2D, 0x55, 0x6E, 0x69, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6C, 0x2D, 0x53, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x2D, 0x4D, 0x65, 0x73, 0x68, 0x2D, 0x30, 0x35, 0x32, 0x3A, 0x7E,
        0x07, 0x1B, 0x5B, 0x3F, 0x31, 0x30, 0x33, 0x34, 0x68, 0x5B, 0x72, 0x6F, 0x6F, 0x74, 0x40,
        0x4B, 0x56, 0x4D, 0x5F, 0x56, 0x4D, 0x2D, 0x55, 0x6E, 0x69, 0x76, 0x65, 0x72, 0x73, 0x61,
        0x6C, 0x2D, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2D, 0x4D, 0x65, 0x73, 0x68, 0x2D,
        0x30, 0x35, 0x32, 0x20, 0x7E, 0x5D, 0x23, 0x20,
    ];
    const TEST_DATA2: &[u8] = &[0x70, 0x77, 0x5C, 0x0D, 0x0A, 0x3E, 0x20];
    const TEST_DATA3: &[u8] = &[0x64];
    const TEST_DATA4: &[u8] = &[
        0x0D, 0x0A, 0x2F, 0x72, 0x6F, 0x6F, 0x74, 0x0D, 0x0A, 0x1B, 0x5D, 0x30, 0x3B, 0x72, 0x6F,
        0x6F, 0x74, 0x40, 0x4B, 0x56, 0x4D, 0x5F, 0x56, 0x4D, 0x2D, 0x55, 0x6E, 0x69, 0x76, 0x65,
        0x72, 0x73, 0x61, 0x6C, 0x2D, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2D, 0x4D, 0x65,
        0x73, 0x68, 0x2D, 0x30, 0x35, 0x32, 0x3A, 0x7E, 0x07, 0x5B, 0x72, 0x6F, 0x6F, 0x74, 0x40,
        0x4B, 0x56, 0x4D, 0x5F, 0x56, 0x4D, 0x2D, 0x55, 0x6E, 0x69, 0x76, 0x65, 0x72, 0x73, 0x61,
        0x6C, 0x2D, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2D, 0x4D, 0x65, 0x73, 0x68, 0x2D,
        0x30, 0x35, 0x32, 0x20, 0x7E, 0x5D, 0x23, 0x20,
    ];
    const TEST_DATA5: &[u8] = &[
        0x0D, 0x0A, 0x1B, 0x5D, 0x30, 0x3B, 0x72, 0x6F, 0x6F, 0x74, 0x40, 0x4B, 0x56, 0x4D, 0x5F,
        0x56, 0x4D, 0x2D, 0x55, 0x6E, 0x69, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6C, 0x2D, 0x53, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x2D, 0x4D, 0x65, 0x73, 0x68, 0x2D, 0x30, 0x35, 0x32, 0x3A,
        0x7E, 0x07, 0x5B, 0x72, 0x6F, 0x6F, 0x74, 0x40, 0x4B, 0x56, 0x4D, 0x5F, 0x56, 0x4D, 0x2D,
        0x55, 0x6E, 0x69, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6C, 0x2D, 0x53, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x2D, 0x4D, 0x65, 0x73, 0x68, 0x2D, 0x30, 0x35, 0x32, 0x20, 0x7E, 0x5D, 0x23,
        0x20,
    ];

    #[test]
    fn test() {
        let mut parser = Parser::new(24, 80, 10);
        parser.process(TEST_DATA1);
        println!("all1 content:\n{}\n", parser.screen().contents());
        // 获取当前光标所在行
        let cu1 = parser.screen().cursor_position();
        println!("cu1: {:?}", cu1);
        parser.process(TEST_DATA2);
        println!("all2 content:\n{}\n", parser.screen().contents());
        parser.process(TEST_DATA3);
        println!("all3 content:\n{}\n", parser.screen().contents());
        let cu2 = parser.screen().cursor_position();
        println!("cu2: {:?}", cu2);
        println!("is line 1 wrapped: {:?}", parser.screen().row_wrapped(1));
        println!("is line 2 wrapped: {:?}", parser.screen().row_wrapped(2));
        parser.process(TEST_DATA4);
        let c4 = parser.screen().contents();
        println!("all4 content:\n{}\n", c4);
        parser.set_size(24, 10);
        parser.process(TEST_DATA5);

        println!("all5 content:\n{}\n", parser.screen().contents());
    }
}
